# 🎯 FreeRTOS第3天：总结报告

## 📅 学习日期：2026年1月21日
## 🎯 主题：理解"调度" - 优先级与阻塞

---

## ✅ 实验验证结果

### 实验1：优先级调整 ✅
**操作：** DisplayTask优先级↑ (Normal → AboveNormal)
**现象：**
- LED闪烁时间出现轻微漂移（约+0.1-0.2秒）
- OLED更新保持准时（每2秒）
- **结论：** 高优先级任务可轻微影响低优先级任务执行时机

### 实验2：阻塞重要性验证 ✅
**操作：** 注释LEDTask中的`osDelay(900)`
**有趣现象：**
- LED常亮（实际快速亮灭，肉眼不可辨）
- OLED仍正常更新（时间片调度起作用）
- **发现：** FreeRTOS有时间片机制，防止完全饿死

---

## 💡 核心概念掌握

### 1. 优先级（Priority）
```c
// 优先级等级
osPriorityLow          // 最低
osPriorityNormal       // 默认（今天的基础）
osPriorityAboveNormal  // 今天实验值
osPriorityHigh         // 可尝试
osPriorityRealtime     // 最高（慎用）
```
**理解：** 就像医院急诊 - 重症(高优先级)插队轻症(低优先级)

### 2. 阻塞（Blocking）
**关键函数：** `osDelay()`<br>
**作用：** 主动让出CPU，说：“我休息一下，你们先干”<br>
**必须性：** 没有阻塞 → 自私任务 → 系统卡顿/死锁

### 3. 时间片（Time Slicing）
**发现：** 即使任务“自私”，同优先级任务仍能运行<br>
**原因：** FreeRTOS强制时间片切换（约1ms）<br>
**意义：** 防止编程错误导致系统完全崩溃

## 🎓技术要点总结

| 概念 | 作用 | 验证方法 | 重要性 |
|---|---|---|---|
| **优先级** | 决定执行顺序 | 调整优先级观察任务时序 | ★★★★☆ |
| **抢占** | 高优打断低优 | 让高优任务长时间运行 | ★★★★☆ |
| **阻塞** | 主动让出CPU | 去掉osDelay观察影响 | ★★★★☆ |
| **时间片** | 防止饿死 | 同优先级"自私"任务实验 | ★★★★☆ |

## 🔍深入理解

### 为什么RTOS需要主动让出？

```text  
单任务系统：我干完你再干（顺序）  
RTOS系统：大家轮流干（并发）  
关键：必须有人说“轮到下一个了”  
osDelay()就是那个“喊换人”的机制  
```
---

### 优先级使用的艺术

```text  
误区：把所有任务设成高优先级  
正解：紧急的、时间敏感的高优先级显示、记录等可低优先级  
原则：能用低就不用高
```

## 实际应用启示

### 未来项目设计原则：
1. **传感器采集**：高优先级（数据不能丢）
2. **数据处理**：中优先级
3. **显示输出**：低优先级（晚0.1秒用户无感）
4. **日志记录**：最低优先级

## 收获与感悟
> 今天体验了优先级和时间片，明白了分配机制